# -*- coding: utf-8 -*-
"""Project_SM_Apple.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15TgV8gWYto1v5DWTGzPSQ3Rz4IRN2Wbr
"""

import pandas as pd 
import numpy as np

data = pd.read_csv('/content/AAPL.csv')

# stock mrkt , equity mrkt or share mrkt is the sum total no of buyers n sellers 
# stock a kind of ownership in one's business
# The adjusted closing price amends a stock's closing price to reflect that stock's value after accounting for 
  # any corporate actions.
# Open-High-Low-Close Charts show the high and low price a stock attained for a particular period of
   #  time as well as the opening and closing prices of the stock for the same period.

data[0:6]

"""**EDA**"""

type(data)

data.shape

data.info()

# checking duplicates
data[data.duplicated()].shape

# missing values 
data.isna().sum()

# statstical analysis
data.describe()

# correlation 
data.corr()

# converting date to datetime
data['Date'] =pd.to_datetime(data['Date'])
data['Month'] = data['Date'].dt.month
data['Year'] = data['Date'].dt.year

data.set_index('Date',inplace=True)

data[0:3]

data.info()

"""**Visualizations**"""

# data visualizations 
import seaborn as sns 
import matplotlib.pyplot as plt
import matplotlib.pyplot as pyplot

data.plot(figsize=(8,6))

sns.lineplot(data['Year'], data['Adj Close'])  # upward going trend

# Line plot
line= plt.subplots(figsize=(10,5))
sns.lineplot(data['Date'], data['Adj Close'])   # upward trend with multiplicative seasonality

sns.lineplot(data['Month'], data['Adj Close'] )  # even no of months in a year are showing upward trend

sns.histplot(data['Adj Close'],kde=True) # right skewed data

sns.boxplot(data['Year'], data['Adj Close']) # year 2012 n 2019 have outliers present

sns.boxplot(data['Month'], data['Adj Close']) # here condering month wise , 12th month (dec) has outliers present

from pandas.plotting import lag_plot    # showing linear relationship i.e yt is affecting with the lag yt-1 it means current month price is
                                          # depend on last month price 
lag_plot(data['Adj Close']);
plt.show()

import statsmodels.graphics.tsaplots as tsa_plots
tsa_plots.plot_acf(data['Adj Close'],lags=12)
tsa_plots.plot_pacf(data['Adj Close'],lags=12)
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose
decompose_ts_add = seasonal_decompose(data.Close, period= 12)
decompose_ts_add.plot()
plt.show()
# showing trend upward 
# seasonality additive as all magnitudes are equal

import statsmodels.api as sm
# Aggregating the Time Series to a monthly scaled index
y =data[[ 'Close']].copy()
y.index = pd.to_datetime(y.index)
y = y.resample('1M').mean()

# Using statistical tools of statsmodel library
decomposition = sm.tsa.seasonal_decompose(y, model='multiplicative')
decomp = decomposition.plot()
decomp.suptitle('Close decomposition', fontsize=22)

"""**Model building **"""

data.head()

# spliting the data
train = data.head(1999)
test = data.tail(12)

train[0:5]

test[0:5]

def MAPE(pred,org):
    adj_close = np.abs((pred-org)/org)*100
    return np.mean(adj_close)

y =data[['Adj Close']]
y.index = pd.to_datetime(y.index)
y = y.resample('1M').mean()
y['Moving Average'] = y.rolling(window=3).mean() 
y.plot(figsize=(15,5));

"""**Simple Exponential **"""

# Plot Simple exponential smoothing
alpha=0.05
y['SES'] = SimpleExpSmoothing(y['Adj Close']).fit(smoothing_level = alpha, optimized = False).fittedvalues.shift(-1)
y[['Adj Close','SES']].plot(figsize=(15,5));

# Double expo. methold 
y['DES'] = ExponentialSmoothing(y['Adj Close'], trend = 'add').fit().fittedvalues.shift(-1)
y['DES']

y[['Adj Close','DES']].plot(figsize = (15,5));

"""Checking Stationarity """

from statsmodels.tsa.stattools import adfuller
test_result=adfuller(data['Adj Close'])

# ho: data is stationary , h1: data is non stationary

def adf_test(series, title=''):
    
    # .dropna() handles differenced data
    result = adfuller(series.dropna(),autolag='AIC') 
    
    labels = ['ADF test statistic','p-value','# lags used','# observations']
    out = pd.Series(result[0:4],index=labels)

    for key,val in result[4].items():
        out['critical value ({})'.format(key)]=val
        
    # .to_string() removes the line "dtype: float64"
    print(out.to_string())          
    
    if result[1] <= 0.05:
        print("Reject the null hypothesis")
        print("Data is stationary")
    else:
        print("Fail to reject the null hypothesis")
        print("Data is non-stationary")

# Aggregating the Time Series to a monthly scaled index
y = data[['Adj Close']].copy()
y.index = pd.to_datetime(y.index)
y = y.resample('1M').mean() 

adf_test(y['Adj Close'],title='')

# Differencing y(t)=y(t)-y(t-1)
data[' Adj Close First Difference'] = data['Adj Close'] -data['Adj Close'].shift(1)

## Again test dickey fuller test for first differencing
adf_test(data[' Adj Close First Difference'].dropna())

data[' Adj Close First Difference'].plot()

# Seasonal Differencing y(t)=y(t)-y(t-n)
data['Seasonal First Difference']=data['Adj Close']-data['Adj Close'].shift(30)

## Again test dickey fuller test
adf_test(data['Seasonal First Difference'].dropna())

data['Seasonal First Difference'].plot()

"""**ARIMA Model** """

from statsmodels.graphics.tsaplots import plot_acf,plot_pacf

fig = plt.figure(figsize=(12,8))
ax1 = fig.add_subplot(211)
fig = plot_acf(data[' Adj Close First Difference'].iloc[31:],lags=60,ax=ax1)
ax2 = fig.add_subplot(212)
fig = plot_pacf(data[' Adj Close First Difference'].iloc[31:],lags=60,ax=ax2)

from statsmodels.tsa.arima_model import ARIMA

import statsmodels.api as sm
import warnings
warnings.filterwarnings('ignore')

model = sm.tsa.arima.ARIMA(data['Adj Close'], order=(1,1,1))
model_fit = model.fit()

model_fit.summary()

data['forecast']=model_fit.predict(start=1761,end=2010)

data[['Adj Close','forecast']].plot(figsize=(12,6))

data['forecast']

"""**SARIMA Model **"""

fig = plt.figure(figsize=(12,8))
ax1 = fig.add_subplot(211)
fig = plot_acf(data['Seasonal First Difference'].iloc[31:],lags=40,ax=ax1)
ax2 = fig.add_subplot(212)
fig = plot_pacf(data['Seasonal First Difference'].iloc[31:],lags=40,ax=ax2)

model1=sm.tsa.statespace.SARIMAX(data['Adj Close'], order=(2,1,1),seasonal_order=(2,1,1,30))
model1_fit=model1.fit()

model1_fit.summary()

model1=sm.tsa.statespace.SARIMAX(data['Adj Close'], order=(1,1,1),seasonal_order=(1,1,1,30))
model1_fit=model1.fit()

model1_fit.summary()

data['forecast1']=model1_fit.predict(start=1761,end=2010,dynamic=True,exog=None)
data[['Adj Close','forecast1']].plot(figsize=(10,5))

from pandas.tseries.offsets import DateOffset
futuredate=[data.index[-1]+ DateOffset(days=x) for x in range (0,30)]

Future_dates_df=pd.DataFrame(index=futuredate[1:],columns=data.columns)

data[0:7]

future_df=pd.concat([data,Future_dates_df],ignore_index=True)

future_df['forecast']=model_fit.predict(start=2011,end=2039)
future_df[['Adj Close','forecast']].plot(figsize=(10,5))

# 30 day's predicted values
future_df['forecast'].tail(30)

future_df

pip install --upgrade scalecast

import pandas as pd
from scalecast.Forecaster import Forecaster
from scalecast import GridGenerator

GridGenerator.get_example_grids()

data = pd.read_csv('AAPL.csv')
f = Forecaster(
   y = data['Adj Close'],
   current_dates = data['Date'],
   future_dates = 24, # forecast horizon
)
f.set_estimator('xgboost')

f.auto_Xvar_select()
f.cross_validate(k=3)
f.auto_forecast()

results = f.export(['lvl_fcsts','model_summaries'])









